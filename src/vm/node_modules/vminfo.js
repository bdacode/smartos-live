/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 */

// Ensure we're using the platform's node
require('/usr/node/node_modules/platform_node_version').assert();

var assert = require('assert');
var bunyan = require('/usr/node/node_modules/bunyan'); // XXX TEMPORARY
var execFile = require('child_process').execFile;
var expat = require('/usr/node/node_modules/node-expat');
var fs = require('fs');
var props = require('/usr/vm/node_modules/props');
var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
var utils = require('utils');

//
var XML_PROPERTIES = props.XML_PROPERTIES;


function transformProperty(key, value, log) {
    var err;
    var result = {};

    log.trace({
        key: {name: key, type: typeof (key)},
        value: {name: value, type: typeof (value)}
    }, 'before transformProperty()');

    if (!XML_PROPERTIES.hasOwnProperty(key)) {
        log.error('"' + key + '" not found in XML_PROPERTIES');
        return null;
    }

    if (XML_PROPERTIES[key].ignore) {
        log.trace('ignoring "' + key + '" due to "ignore" XML_PROPERTIES');
        return null;
    }

    // XXX redo this as an assert
    if (!XML_PROPERTIES[key].hasOwnProperty('objname')) {
        err = new Error('XML_PROPERTIES missing objname for "' + key + '"');
        throw (err);
    }

    result.key = XML_PROPERTIES[key].objname;

    if (XML_PROPERTIES[key].hasOwnProperty('loadValueTranslator')) {
        result.value = XML_PROPERTIES[key].loadValueTranslator(value);
    } else {
        result.value = value;
    }

    log.trace({
        key: {name: result.key, type: typeof (result.key)},
        value: {name: result.value, type: typeof (result.value)}
    }, 'after transformProperty()');

    return result;
}

function startElement(name, attrs, state, log) {
    var disk;
    var filesystem;
    var k;
    var nic;
    var obj;
    var stack;
    var transformed;
    var value;
    var where;

    assert(log, 'no logger passed to startElement()');

    if (!state.hasOwnProperty('stack')) {
        state.stack = [];
    }

    obj = state.obj;
    stack = state.stack;
    stack.push(name);
    where = stack.join('.');

    if (where === 'zone') {
        Object.keys(attrs).forEach(function (key) {
            k = where + '.' + key;
            transformed = transformProperty(k, attrs[key], log);
            if (!transformed) {
                return;
            }
            obj[transformed.key] = transformed.value;
        });
    } else if (where === 'zone.attr') {
        k = where + '.' + attrs.name;
        transformed = transformProperty(k, attrs.value, log);
        if (!transformed) {
            return;
        }
        obj[transformed.key] = transformed.value;
    } else if (where === 'zone.dataset') {
        /*
         * zone.dataset is special in that attrs has only a 'name' and we're
         * just making an array of the names, so we don't pass through
         * transformProperty() like the others.
         */
        if (!obj.datasets) {
            obj.datasets = [];
        }
        obj.datasets.push(attrs.name);
    } else if (where === 'zone.device') {
        disk = {};
        Object.keys(attrs).forEach(function (key) {
            k = stack.join('.') + '.' + key;
            transformed = transformProperty(k, attrs[key], log);
            if (!transformed) {
                return;
            }
            disk[transformed.key] = transformed.value;
        });
        if (!obj.disks) {
            obj.disks = [];
        }
        obj.disks.push(disk);
    } else if (where === 'zone.device.net-attr') {
        disk = obj.disks[obj.disks.length - 1];
        k = where + '.' + attrs.name;
        transformed = transformProperty(k, attrs.value, log);
        if (!transformed) {
            return;
        }
        disk[transformed.key] = transformed.value;
    } else if (where === 'zone.filesystem') {
        filesystem = {};
        Object.keys(attrs).forEach(function (key) {
            k = stack.join('.') + '.' + key;
            transformed = transformProperty(k, attrs[key], log);
            if (!transformed) {
                return;
            }
            filesystem[transformed.key] = transformed.value;
        });
        if (!obj.filesystems) {
            obj.filesystems = [];
        }
        obj.filesystems.push(filesystem);
    } else if (where === 'zone.filesystem.fsoption') {
        /*
         * filesystem.fsoptions is special in that attrs has only a 'name' and
         * we're just making an array of the names, so we don't pass through
         * transformProperty() like the others.
         */
        filesystem = obj.filesystems[obj.filesystems.length - 1];
        if (!filesystem.options) {
            filesystem.options = [];
        }
        filesystem.options.push(attrs.name);
    } else if (where === 'zone.network') {
        nic = {};
        Object.keys(attrs).forEach(function (key) {
            k = stack.join('.') + '.' + key;
            transformed = transformProperty(k, attrs[key], log);
            if (!transformed) {
                return;
            }
            nic[transformed.key] = transformed.value;
        });
        if (!obj.nics) {
            obj.nics = [];
        }
        obj.nics.push(nic);
    } else if (where === 'zone.network.net-attr') {
        nic = obj.nics[obj.nics.length - 1];
        k = where + '.' + attrs.name;
        transformed = transformProperty(k, attrs.value, log);
        if (!transformed) {
            return;
        }
        nic[transformed.key] = transformed.value;
    } else if (where === 'zone.rctl') {
        stack.push(attrs.name);
    } else if ((value = where.match(/^(zone.rctl.zone.*.)rctl-value$/))) {
        k = value[1] + attrs.priv + '.' + attrs.action;
        transformed = transformProperty(k, attrs.limit, log);
        if (!transformed) {
            return;
        }
        obj[transformed.key] = transformed.value;
    } else {
        log.error({where: where, attrs: attrs}, 'unhandled zone XML property');
    }
}

function endElement(name, state) {
    // trim stack back above this element
    var stack = state.stack;

    while (stack.pop() !== name) {
        // do nothing, we just want to consume.
        continue;
    }
}

// This function parses the zone XML file at /etc/zones/<zonename>.xml and adds
// the VM properties to a new object.
function getVmobj(zonename, preload_data, options, callback)
{
    var filename = '/etc/zones/' + zonename + '.xml';
    var log;
    var parser = new expat.Parser('UTF-8');

    assert(options.log, 'no logger passed to getVmobj()');
    log = options.log;

    fs.readFile(filename, function (error, data) {
        var fields;
        var obj = {};
        var state = {};

        if (error) {
            callback(error);
            return;
        }

        state.obj = obj;
        parser.on('startElement', function (name, attrs) {
            startElement(name, attrs, state, log);
            return;
        });
        parser.on('endElement', function (name) {
            endElement(name, state);
            return;
        });

        if (!parser.parse(data.toString())) {
            throw new Error('There are errors in your xml file: '
                + parser.getError());
        }

        // TODO: remove properties not in allowed list for this brand

        /*
         * TODO: check if known brand
         * if (!BRAND_OPTIONS.hasOwnProperty(obj.brand)) {
         *   throw new Error('unable to handle brand ' + obj.brand);
         * }
         */

        /*
         * TODO: check if we use autoboot or vm_autoboot for this brand
         * if (BRAND_OPTIONS[obj.brand].features.use_vm_autoboot) {
         *    obj.autoboot = obj.vm_autoboot;
         *    delete obj.vm_autoboot;
         * }
         */

        /*
         * TODO: fill in dataset properties for zone disks ?
         * XXX should we do this here or in the caller?
         */
        // probe for some fields on disks if this brand of zone supports them.
        // if (allowed.hasOwnProperty('disks')
            // && (allowed.disks.indexOf('create') !== -1)) {

            // for (disk in obj.disks) {
                // disk = obj.disks[disk];

                // if (preload_data.hasOwnProperty('dsinfo')) {
                    // dsinfo = preload_data.dsinfo;
                    // if (dsinfo.hasOwnProperty('mountpoints')
                        // && dsinfo.mountpoints.hasOwnProperty(disk.path)) {

                        // disk.zfs_filesystem = dsinfo.mountpoints[disk.path];
                        // disk.zpool = disk.zfs_filesystem.split('/')[0];
                    // } else {
                        // log.trace('no mountpoint data for ' + disk.path);
                    // }
                // }
            // }
        // }

        if (obj.hasOwnProperty('transition')) {
            fields = utils.rtrim(obj.transition).split(':');
            if (fields.length === 3) {
                delete obj.transition;
                obj.state = fields[0];
                obj.transition_to = fields[1];
                obj.transition_expire = fields[2];
            } else {
                log.debug('getVmobj() ignoring bad value for '
                    + 'transition "' + obj.transition + '"');
            }
        }

        // sort the disks + nics by index
        if (obj.hasOwnProperty('disks')) {
            indexSort(obj.disks, 'path', /^.*-disk(\d+)$/);
        }
        if (obj.hasOwnProperty('nics')) {
            indexSort(obj.nics, 'interface', /^net(\d+)$/);
        }
        if (obj.hasOwnProperty('filesystems')) {
            indexSort(obj.filesystems, 'target', /^(.*)$/);
        }

        callback(null, obj);
    });
}

function indexSort(obj, field, pattern)
{
    obj.sort(function (a, b) {
        var avalue = 0;
        var bvalue = 0;
        var matches;

        if (a.hasOwnProperty(field)) {
            matches = a[field].match(pattern);
            if (matches) {
                avalue = Number(matches[1]);
            }
        }
        if (b.hasOwnProperty(field)) {
            matches = b[field].match(pattern);
            if (matches) {
                bvalue = Number(matches[1]);
            }
        }

        return avalue - bvalue;
    });
}

execFile('/usr/sbin/zoneadm', ['list', '-c'], function (error, stdout, stderr) {
    var vms = stdout.split(/\n/);
    vms.forEach(function (vm) {
        if (vm.length != 36) {
            return;
        }
        getVmobj(vm, {},
            {log: bunyan.createLogger({level: 'debug', name: 'foo'})},
            function (err, obj) {

            console.log('<boom>');
            console.log(JSON.stringify(obj, null, 2));
            console.log('</boom>');
        });
    });
});
